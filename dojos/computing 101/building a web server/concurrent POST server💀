# challenge: concurrent POST server

üìÖ 2025-09-21
üìÅ building a web server

---

## ‚úÖ what i did  
-clicked start
-opened the terminal
-ran: 'vim bro.s'
-typed: '.intel_syntax noprefix'
        '.global _start'
        '.data'
        'response:       .ascii  "HTTP/1.0 200 OK\r\n\r\n"'
        'response_len= . - response'
        'client: .skip   1024'
        'content:        .skip   1024'
        'space:  .ascii  " "'
        'new_line:       .ascii  "\r\n\r\n"'
        '.text'
        '_start:'
        '#SOCKET'
        'mov rax, 41'
        'mov rdi, 2'
        'mov rsi, 1'
        'mov rdx, 0'
        'syscall'
        'mov r8, rax'
        '#BIND'
        'mov rax, 49'
        'mov rdi, r8'
        'sub rsp, 16'
        'mov rsi, 0x2'
        'mov [rsp], si'
        'mov rsi, 0x5000'
        'mov [rsp+2], si'
        'mov rsi, 0'
        'mov [rsp+4], esi'
        'mov rsi, rsp'
        'mov rdx, 16'
        'syscall'
        '#LISTEN'
        'mov rax, 50'
        'mov rdi, r8'
        'mov rsi, 0'
        'syscall'
        'LOOP:'
        '#ACCEPT'
        'mov rax, 43'
        'mov rdi, r8'
        'mov rsi, 0'
        'mov rdx, 0'
        'syscall'
        'mov r9, rax'
        '#FORK'
        'mov rax, 57'
        'syscall'
        '#PARENT OR CHILD?'
        'cmp rax, 0'
        'je CHILD'
        'jmp PARENT'
        'CHILD:'
        '#CLOSE'
        'mov rax, 3'
        'mov rdi, r8'
        'syscall'
        '#READ'
        'mov rax, 0'
        'mov rdi, r9'
        'lea rsi, client'
        'mov rdx, 1024'
        'syscall'
        'mov r10, rax'
        '#OPEN'
        'lea rax, client'
        'lea rbx, space'
        'mov bl, [rbx]'
        'trova:'
        'mov cl, [rax]'
        'cmp bl, cl'
        'je trovato'
        'inc rax'
        'jmp trova'
        'trovato:'
        'inc rax'
        'push rax'
        'address:'
        'mov cl, [rax]'
        'cmp cl, bl'
        'je done'
        'inc rax'
        'jmp address'
        'done:'
        'mov rbx, 0'
        'mov [rax], bl'
        'pop rdi'
        'mov rsi, 0x41'
        'mov rdx, 0777'
        'mov rax, 2'
        'syscall'
        'mov r12, rax'
        '#WRITE'
        'lea rax, client'
        'xor r13, r13'
        'find:'
        'inc r13'
        'xor r14, r14'
        'lea rbx, new_line'
        'mov cl, [rax]'
        'mov dil, [rbx]'
        'cmp dil, cl'
        'je first'
        'inc rax'
        'jmp find'
        'first:'
        'inc r14'
        'cmp r14, 4'
        'je donee'
        'inc r13'
        'inc rax'
        'inc rbx'
        'mov cl, [rax]'
        'mov dil, [rbx]'
        'cmp cl, dil'
        'je first'
        'inc rax'
        'jmp find'
        'donee:'
        'inc rax'
        'sub r10, r13'
        'mov rdx, r10'
        'mov rsi, rax'
        'mov rdi, r12'
        'mov rax, 1'
        'syscall'
        '#CLOSE'
        'mov rax, 3'
        'mov rdi, r12'
        'syscall'
        '#WRITE'
        'mov rax, 1'
        'mov rdi, r9'
        'lea rsi, response'
        'mov rdx, response_len'
        'syscall'
        '#EXIT'
        'mov rax, 60'
        'mov rdi, 0'
        'syscall'
        'PARENT:'
        '#CLOSE'
        'mov rax, 3'
        'mov rdi, r9'
        'syscall'
        'jmp LOOP'
-ran: 'as -o bro.o bro.s'
-ran: 'ld -o bro bro.o'
-ran: '/challenge/run bro'
-flag popped out

## üßëüèæ‚Äçüè´ what this challenge teaches u
how to handle POST requests and parse the full request
the POST request contain: REQUEST (the file needed), HEADER (client's details) and BODY (content the client is sending to the server)
its crucial to parse correctly the full request to extract the file needed and body's content
a good way can be saving the full request in a variable and then use a register as a pointer to go directly to the byte needed
then figure out how many bytes the write syscall has to print
the first goal is to extract the url
exactly same way as concurrent GET server
the second goal is to open the right file. same way as concurrent GET server
in this case the open syscall takes as second argument O_WRONLY|O_CREAT it means write only or create the file. 
O_RDONLY = 0
O_WRONLY = 1
O_RDWR = 2
O_CREAT = 64
O_WRONLY|O_CREAT = 65 (dec) = 0x41 (hex)
the third argument handles file's permissions that has been created (0_CREATE) -> rwxrwxrwx=0777
the third goal is to write correctly in the file that has been opened
i achieved that by parsing the full client's request untill i find \r\n\r\n. that's a double CRLF and it means after that there's the body
once i found the first address of the very first body content, the goal is to count how many bytes to write
the idea is: read's result - number of byte that has been count from the first byte of the requests until the the second \n (included) of \r\n\r\n = rdx
this challenge was pretty though but helped me A LOT understanding deeply how to parse requests and handle multiple syscall and their results
  
## üèÅ Flag
pwn.college{oGIYVtSJabHppIOGyQTZeDIQfdQ.QX5QzMzwCO4IDOxEzW}
